import { Injectable, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import Stripe from 'stripe';
import { Payment } from './schemas/payments.schema';

@Injectable()
export class PaymentService {
  private stripe: Stripe;

  constructor(
    @InjectModel(Payment.name) private paymentModel: Model<Payment>,
  ) {
    const stripeSecretKey = process.env.STRIPE_TEST_SECRET_KEY;
    if (!stripeSecretKey) {
      throw new BadRequestException('Stripe secret key not configured');
    }

    this.stripe = new Stripe(stripeSecretKey, {
      apiVersion: '2024-09-30.acacia',
    });
  }

  async createCustomer(email: string, userId: string) {
    try {
      const customer = await this.stripe.customers.create({
        email,
        metadata: {
          userId: String(userId),
        },
      });
      return customer;
    } catch (error) {
      console.error('Error creating customer:', error);
      throw new BadRequestException('Failed to create customer');
    }
  }

  async createPaymentIntent(userId: string, amount: number, currency: string, email: string, name: string, customerId: string, productName: string) {
    const paymentData = {
      userId,
      amount,
      email,
      name,
      productName,
      method: 'card', 
      currency,
      customerId, 
      paymentIntentId: '', 
      status: 'pending', 
    };

    if (!paymentData.method || !paymentData.customerId) {
      throw new BadRequestException('Payment method and customer ID are required');
    }

    const paymentIntent = await this.stripe.paymentIntents.create({
      amount: paymentData.amount,
      currency: paymentData.currency,
      payment_method_types: ['card'], 
    });

    const newPayment = await this.paymentModel.create({
      ...paymentData,
      paymentIntentId: paymentIntent.id,
      status: paymentIntent.status,
      invoice: paymentIntent.invoice,
    });

    return newPayment;
  }

  async confirmPayment(paymentIntentId: string) {
    try {
      const paymentIntent = await this.stripe.paymentIntents.confirm(paymentIntentId, {
        payment_method: 'pm_card_visa', // Update this according to your needs
      });

      await this.paymentModel.updateOne(
        { paymentIntentId },
        { status: paymentIntent.status }
      );

      return paymentIntent;
    } catch (error) {
      console.error('Error confirming payment:', error.message);
      throw new BadRequestException('Failed to confirm payment');
    }
  }

// PaymentService.ts

async createPaymentMethod(customerId: string, token: string) {
  try {
    const paymentMethod = await this.stripe.paymentMethods.create({
      type: 'card',
      card: {
        token, // Use the token generated from Stripe.js
      },
    });

    // Attach the Payment Method to the Customer
    await this.attachPaymentMethodToCustomer(paymentMethod.id, customerId);
    return paymentMethod;
  } catch (error) {
    console.error('Error creating payment method:', error);
    throw new BadRequestException('Failed to create payment method: ' + error.message);
  }
}



  // Attach the created Payment Method to the Customer
  async attachPaymentMethodToCustomer(paymentMethodId: string, customerId: string) {
    try {
      await this.stripe.paymentMethods.attach(paymentMethodId, {
        customer: customerId,
      });
    } catch (error) {
      console.error('Error attaching payment method to customer:', error);
      throw new BadRequestException('Failed to attach payment method to customer: ' + error.message);
    }
  }
}
